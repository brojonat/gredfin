// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: property_query.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProperty = `-- name: CreateProperty :one
INSERT INTO property (
  property_id, listing_id, address, zipcode, state, last_scrape_ts, last_scrape_status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING property_id, listing_id, address, zipcode, state, last_scrape_ts, last_scrape_status
`

type CreatePropertyParams struct {
	PropertyID       string           `json:"property_id"`
	ListingID        string           `json:"listing_id"`
	Address          pgtype.Text      `json:"address"`
	Zipcode          pgtype.Text      `json:"zipcode"`
	State            pgtype.Text      `json:"state"`
	LastScrapeTs     pgtype.Timestamp `json:"last_scrape_ts"`
	LastScrapeStatus pgtype.Text      `json:"last_scrape_status"`
}

func (q *Queries) CreateProperty(ctx context.Context, arg CreatePropertyParams) (Property, error) {
	row := q.db.QueryRow(ctx, createProperty,
		arg.PropertyID,
		arg.ListingID,
		arg.Address,
		arg.Zipcode,
		arg.State,
		arg.LastScrapeTs,
		arg.LastScrapeStatus,
	)
	var i Property
	err := row.Scan(
		&i.PropertyID,
		&i.ListingID,
		&i.Address,
		&i.Zipcode,
		&i.State,
		&i.LastScrapeTs,
		&i.LastScrapeStatus,
	)
	return i, err
}

const deleteProperty = `-- name: DeleteProperty :exec
DELETE FROM property
WHERE property_id = $1 AND listing_id = $2
`

type DeletePropertyParams struct {
	PropertyID string `json:"property_id"`
	ListingID  string `json:"listing_id"`
}

func (q *Queries) DeleteProperty(ctx context.Context, arg DeletePropertyParams) error {
	_, err := q.db.Exec(ctx, deleteProperty, arg.PropertyID, arg.ListingID)
	return err
}

const deletePropertyByAddr = `-- name: DeletePropertyByAddr :exec
DELETE FROM property
WHERE address = $1
`

func (q *Queries) DeletePropertyByAddr(ctx context.Context, address pgtype.Text) error {
	_, err := q.db.Exec(ctx, deletePropertyByAddr, address)
	return err
}

const getNNextPropertyScrapeForUpdate = `-- name: GetNNextPropertyScrapeForUpdate :one
SELECT property_id, listing_id, address, zipcode, state, last_scrape_ts, last_scrape_status FROM property
WHERE last_scrape_status = ANY($2::VARCHAR[])
ORDER BY NOW()::timestamp - last_scrape_status
LIMIT $1
FOR UPDATE
`

type GetNNextPropertyScrapeForUpdateParams struct {
	Limit   int32    `json:"limit"`
	Column2 []string `json:"column_2"`
}

// Get the next N property entries that have a last_scrape_status in the
// supplied slice. Rows are locked for update; callers are expected to set
// status rows to PENDING after retrieving rows.
func (q *Queries) GetNNextPropertyScrapeForUpdate(ctx context.Context, arg GetNNextPropertyScrapeForUpdateParams) (Property, error) {
	row := q.db.QueryRow(ctx, getNNextPropertyScrapeForUpdate, arg.Limit, arg.Column2)
	var i Property
	err := row.Scan(
		&i.PropertyID,
		&i.ListingID,
		&i.Address,
		&i.Zipcode,
		&i.State,
		&i.LastScrapeTs,
		&i.LastScrapeStatus,
	)
	return i, err
}

const getProperty = `-- name: GetProperty :one
SELECT property_id, listing_id, address, zipcode, state, last_scrape_ts, last_scrape_status FROM property
WHERE property_id = $1 LIMIT 1
`

func (q *Queries) GetProperty(ctx context.Context, propertyID string) (Property, error) {
	row := q.db.QueryRow(ctx, getProperty, propertyID)
	var i Property
	err := row.Scan(
		&i.PropertyID,
		&i.ListingID,
		&i.Address,
		&i.Zipcode,
		&i.State,
		&i.LastScrapeTs,
		&i.LastScrapeStatus,
	)
	return i, err
}

const listProperties = `-- name: ListProperties :many
SELECT property_id, listing_id, address, zipcode, state, last_scrape_ts, last_scrape_status FROM property
ORDER BY property_id
`

func (q *Queries) ListProperties(ctx context.Context) ([]Property, error) {
	rows, err := q.db.Query(ctx, listProperties)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.PropertyID,
			&i.ListingID,
			&i.Address,
			&i.Zipcode,
			&i.State,
			&i.LastScrapeTs,
			&i.LastScrapeStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postProperty = `-- name: PostProperty :exec
UPDATE property
  SET address = $3,
  zipcode = $4,
  state = $5,
  last_scrape_ts = $6,
  last_scrape_status = $7
WHERE property_id = $1 AND listing_id = $2
`

type PostPropertyParams struct {
	PropertyID       string           `json:"property_id"`
	ListingID        string           `json:"listing_id"`
	Address          pgtype.Text      `json:"address"`
	Zipcode          pgtype.Text      `json:"zipcode"`
	State            pgtype.Text      `json:"state"`
	LastScrapeTs     pgtype.Timestamp `json:"last_scrape_ts"`
	LastScrapeStatus pgtype.Text      `json:"last_scrape_status"`
}

func (q *Queries) PostProperty(ctx context.Context, arg PostPropertyParams) error {
	_, err := q.db.Exec(ctx, postProperty,
		arg.PropertyID,
		arg.ListingID,
		arg.Address,
		arg.Zipcode,
		arg.State,
		arg.LastScrapeTs,
		arg.LastScrapeStatus,
	)
	return err
}

const updatePropertyStatus = `-- name: UpdatePropertyStatus :exec
UPDATE property
  SET last_scrape_ts = NOW()::timestamp,
  last_scrape_status = $3
WHERE property_id = $1 AND listing_id = $2
`

type UpdatePropertyStatusParams struct {
	PropertyID       string      `json:"property_id"`
	ListingID        string      `json:"listing_id"`
	LastScrapeStatus pgtype.Text `json:"last_scrape_status"`
}

func (q *Queries) UpdatePropertyStatus(ctx context.Context, arg UpdatePropertyStatusParams) error {
	_, err := q.db.Exec(ctx, updatePropertyStatus, arg.PropertyID, arg.ListingID, arg.LastScrapeStatus)
	return err
}
